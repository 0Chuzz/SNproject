#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
problem
\end_layout

\begin_layout Standard
Perform computer vision task in embedded sistem, like tracking.
 Implement algorithm with limited space and time.
 We focused on two separate task on object tracking, component labeling
 and trajectory prediction.
\end_layout

\begin_layout Section
Labeling
\end_layout

\begin_layout Subsection
introduction
\end_layout

\begin_layout Standard
Connected component labeling is the process splitting groundthruts images
 into separate components.
 The starting image is a 320x240 black/white image.
 And a result we get a set of blobs.
 For a black and white image, using 1 bit per pixel 9600 bytes are needed
 to store one image, while having a 8 bit label for each pixel implies allocatin
g 76800 bytes per image.
 On embedded system we can suppose to have from 256k to 64k of total available
 memory for the whole tracking task, so the memory requirements are so stringent
 that only few bits per pixel can be afforded.
 The developed algorithms allows component labeling to be performed using
 less than 20k of memory.
\end_layout

\begin_layout Subsection
reference implementation
\end_layout

\begin_layout Standard
First implementation from paper SCOPES , the algorithm scans the image and
 perform an union find, where a different label is assigned to each new
 foreground pixel and adjacent pixel are joined in a single set.
 This algorithm has high memory use, mainly caused by the high number of
 temporary labels required, and so the number of connected components is
 limited by the space used.
\end_layout

\begin_layout Subsection
first solution
\end_layout

\begin_layout Standard
The first modification allows to use only 2 BW buffers.
 The difference arises by the behaviour of the algorithm when a pixel that
 is disconnected from the first connected blob is detected.
 Instead of getting a new label, it is ignored and stays in the background.
 Eventually the algorithm will find that a pixel belonging to our blob is
 connected to previously ignored pixels.
 In this case, it performs a successive scan of the raster in the opposite
 direction.
 This process continues in loop until no connected pixels are left.
 As a result we obtain a buffer containing a single connected shape, that
 can then be processed separately, deleted from the mask image in order
 to extract the successive blob.
 This transforms the union find algorithm into a incremental algorithm as
 the connected components are extracted from the original mask one at a
 time.
 So at the price of increased cpu usage we can separate the connected components
 with a low memory footprint.
 The duration of the algorithm for a single blob depends both on the size
 and on its shape, and the number of raster scan can be very high in worst
 case scenario.
\end_layout

\begin_layout Standard
A way to limit the number of raster scans can be to increase the number
 of intermediate buffers for pixel labels, so by utilizing an hybrid union-find
 algorithm.
 This implies using a low number of labels, and using multiple passes when
 they are not enough.
 This create a time-memory trade off scenario, but does not solve the unpredicta
bility of the number of passes.
\end_layout

\begin_layout Subsection
second solution
\end_layout

\begin_layout Standard
A better time bound can be obtained by changing approach.
 The main inspiration has been the labirint algorithm, where by visiting
 the rightmost corridor allows to visit the whole labirinth.
 In pratice the blobs is considered a graph, and a spanning tree is traversed.
 This algorithm requires 2 BW buffers, 2 BW temporary on the stack.
 After finding a pixel it begins to move through the shape with a simple
 algorithm, move to the rightmost unvisited pixel.
 The two temporary buffers are used to store the path taken, in order to
 allow backtracking.
 Because of this it uses more memory, but each shape pixel is visited at
 most four times.
 
\end_layout

\begin_layout Subsection
future work
\end_layout

\begin_layout Standard
in all the algorithms the BW buffers are considered bit by bit, and no attempt
 is made to exploit cpu word size instead.
 This should lead to performance improvements especially in 32 bits systems.
 According to the timing requirements the labeling algorithm can be applied
 to downscaled images.
\end_layout

\begin_layout Standard
SCOPES: Smart Cameras Object Position Estimation System
\end_layout

\end_body
\end_document
